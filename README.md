# Java_RH
https://github.com/AnthonyPAlicea/JavascriptUnderstandingTheWeirdParts/tree/master/D2_ObjectLiterals/Finished

get extention live server
right click on the html file to open and see it.
Hoisting
all variable are set undefined till the script is running and function is in memory

# Single threaded : one command at a time
# Synchronous: one at a time
# Invocation: running a fuction: parenthesis()
# Asychronous: more than one at a time
function b() {};

Global execution context (created and code is executed)
Then if function is running there will be a private execution context.


Thr broser--> redenring engine <--> Java script engine --> HTTP request

The keywords let and var both declare new variables in JavaScript. The difference between let and var is in the scope of the variables they create:

Variables declared by let are only available inside the block where they’re defined.
Variables declared by var are available throughout the function in which they’re declared.

# Dynamic typing: it will figure during execution

UNDEFINED : represents lack of existence
NULL : lack of existence
BOOLEAN
NUMBER
STRING
SYMBOL

## put ; after return{}


## Call back function: a function you give to another function to be run when the other function is finished.

## function curryinh: creating a copy of a function buy with some preset parameters.

resource:
https://lodash.com/

https://underscorejs.org/docs/underscore-esm.html

https://momentjs.com/
strict mode
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode

http://www.typescriptland.org/Playground

https://www.youtube.com/TonyAlicea


# Reflection: anobject can look as itself, listening and change its properties and methods.

# function constructor: a noemal function that is used to construct objects.

# Polyfill  Code that adds a feature which the engine may lack.
# JQUEY is a libary

# Transpile: convert the syntax of one programming language to another. Exapmle type script. Traceur complier

# Method Chaining: calling one method after anohter and each method affects the parent object. so obj.method1().method2() where both methods end up with a this variable pointing at obj
